<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin: 0; padding: 0; height: 100%; }
    #wrap { width: 100%; margin: 0 auto; }
    /* Height is dynamically overridden from Python via renderFigure(heightPx). */
    #chart { width: 100%; height: 320px; }
    /* Hide Plotly hover labels/tooltips while keeping hover/click events and spikelines.
       On mobile, Plotly can render a hover box that sometimes contains only color swatches;
       hiding the entire hoverlayer removes that box while preserving spikelines (separate layer). */
    #table {
      width: 100%;
      box-sizing: border-box;
      padding: 6px 10px 10px 10px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      font-size: 12px;
      line-height: 1.25;
    }
    #table .hdr {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 8px;
      margin: 0 0 6px 0;
      color: rgba(49, 51, 63, 0.8);
    }
    #table .hdr .title { font-weight: 600; }
    #table table {
      width: 100%;
      table-layout: fixed;
      border-collapse: collapse;
    }
    #table thead th {
      text-align: right;
      font-weight: 600;
      padding: 4px 6px;
      border-bottom: 1px solid rgba(49, 51, 63, 0.15);
      color: rgba(49, 51, 63, 0.85);
    }
    #table thead th:first-child { text-align: left; }
    /* Keep the % column narrow so the name column doesn't overflow on mobile */
    #table thead th:nth-child(2),
    #table tbody td:nth-child(2) { width: 84px; }
    #table tbody td {
      padding: 3px 6px;
      border-bottom: 1px solid rgba(49, 51, 63, 0.08);
      vertical-align: middle;
    }
    #table tbody td:nth-child(1) { text-align: left; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    #table tbody td:nth-child(2) { text-align: right; font-variant-numeric: tabular-nums; white-space: nowrap; }
    .swatch {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 2px;
      margin-right: 6px;
      vertical-align: middle;
    }
  
    /* Added by full v5.0.1: compact spacing */
    #table td, #table th { padding-right: 8px; }
    #table tbody td:nth-child(2),
    #table tbody td:nth-child(3) { white-space: nowrap; }

    /* Ticker name (secondary text) */
    .name {
      display: inline-block;
      max-width: 160px;
      margin-left: 6px;
      color: rgba(49, 51, 63, 0.72);
      overflow: hidden;
      text-overflow: ellipsis;
      vertical-align: bottom;
      white-space: nowrap;
    }
    @media (max-width: 480px) {
      .name { max-width: 110px; }
      #table thead th:nth-child(2),
      #table tbody td:nth-child(2) { width: 76px; }
    }
    /* NOTE:
      We do not mask the chart area, because it can hide titles and axis labels.
      Hover labels are minimized via Plotly layout.hoverlabel in renderFigure().
    */
    .hoverlayer .hovertext { display: none !important; }

</style>
</head>
<body>
  <div id="wrap">
    <div id="quickbar"></div>
    <div id="chart"></div>
    <div id="table"></div>
  </div>
  <script src="https://cdn.plot.ly/plotly-2.4.1.min.js"></script>
  <script>
    const wrapDiv = document.getElementById('wrap');
    const quickDiv = document.getElementById('quickbar');
    const chartDiv = document.getElementById('chart');
    const tableDiv = document.getElementById('table');
    let lastFigKey = null;
    let tableData = null;
    let xMs = null;
    let order = [];
    let names = {};
    let colors = {};
    let series = {};
    let datasets = { daily: null, intraday: null };
    let lastIndex = -1;
    let rafPending = false;

    function postToStreamlit(msg) {
      window.parent.postMessage({ isStreamlitMessage: true, ...msg }, '*');
    }

    function setFrameHeight() {
      try {
        const height = Math.max(document.body.scrollHeight || 0, 420);
        postToStreamlit({ type: 'streamlit:setFrameHeight', height });
      } catch (e) {
        postToStreamlit({ type: 'streamlit:setFrameHeight', height: 420 });
      }
    }

    function buildTableSkeleton() {
      if (!tableDiv) return;
      tableDiv.innerHTML = '';

      const hdr = document.createElement('div');
      hdr.className = 'hdr';
      const title = document.createElement('div');
      title.className = 'title';
      title.textContent = 'カーソル時点の変化率';
      const stamp = document.createElement('div');
      stamp.className = 'stamp';
      stamp.textContent = '';
      hdr.appendChild(title);
      hdr.appendChild(stamp);
      tableDiv.appendChild(hdr);

      const tbl = document.createElement('table');
      const thead = document.createElement('thead');
      const trh = document.createElement('tr');
      const th0 = document.createElement('th');
      th0.textContent = '銘柄';
      const th1 = document.createElement('th');
      th1.textContent = '変化率(%)';
      trh.appendChild(th0);
      trh.appendChild(th1);
      thead.appendChild(trh);
      tbl.appendChild(thead);

      const tbody = document.createElement('tbody');
      tbl.appendChild(tbody);
      tableDiv.appendChild(tbl);
    }

    function setStamp(text) {
      const el = tableDiv && tableDiv.querySelector && tableDiv.querySelector('.stamp');
      if (el) el.textContent = text || '';
    }

    function nearestIndex(ms) {
      if (!xMs || xMs.length === 0 || !isFinite(ms)) return -1;
      // Binary search for rightmost <= ms
      let lo = 0;
      let hi = xMs.length - 1;
      if (ms <= xMs[0]) return 0;
      if (ms >= xMs[hi]) return hi;
      while (lo <= hi) {
        const mid = (lo + hi) >> 1;
        const v = xMs[mid];
        if (v === ms) return mid;
        if (v < ms) lo = mid + 1;
        else hi = mid - 1;
      }
      return Math.max(0, hi);
    }

    function renderTableAtIndex(idx) {
      if (!tableDiv || !series || !order || idx < 0) return;
      if (idx === lastIndex) return;
      lastIndex = idx;

      const tbody = tableDiv.querySelector('tbody');
      if (!tbody) return;
      tbody.innerHTML = '';

      // Compute rows
      const rows = [];
      for (const t of order) {
        const arr = series[t];
        if (!arr || idx >= arr.length) continue;
        const v = arr[idx];
        if (v == null || !isFinite(v)) continue;
        const pct = (v - 1.0) * 100.0;
        rows.push({ ticker: t, name: names[t] || t, pct: pct, color: colors[t] || '#777' });
      }
      // Keep fixed order (no resort on hover)

      for (const r of rows) {
        const tr = document.createElement('tr');
        const td0 = document.createElement('td');
        td0.style.textAlign = 'left';
        const sw = document.createElement('span');
        sw.className = 'swatch';
        sw.style.background = r.color;
        td0.appendChild(sw);
        const txt = document.createElement('span');
        txt.textContent = `${r.ticker}`;
        txt.title = `${r.name}`;
        td0.appendChild(txt);

        // Visible name next to ticker (if available and not identical)
        if (r.name && r.name !== r.ticker) {
          const nm = document.createElement('span');
          nm.className = 'name';
          nm.textContent = `${r.name}`;
          td0.appendChild(nm);
        }

        const td1 = document.createElement('td');
        td1.style.textAlign = 'right';
        td1.textContent = (Math.round(r.pct * 100) / 100).toFixed(2);
        tr.appendChild(td0);
        tr.appendChild(td1);
        tbody.appendChild(tr);
      }

      // timestamp label
      try {
        const iso = tableData && tableData.x && tableData.x[idx] ? tableData.x[idx] : '';
        setStamp(iso ? `@ ${iso}` : '');
      } catch (e) {}

      setFrameHeight();
    }

    function scheduleTableUpdate(idx) {
      if (rafPending) {
        lastIndex = -1; // force update on next frame
      }
      rafPending = true;
      window.requestAnimationFrame(() => {
        rafPending = false;
        renderTableAtIndex(idx);
      });
    }

    function buildQuickBar() {
      try {
        if (!quickDiv) return;
        quickDiv.innerHTML = '';
        quickDiv.style.display = 'flex';
        quickDiv.style.flexWrap = 'wrap';
        quickDiv.style.gap = '6px';
        quickDiv.style.padding = '8px 10px 2px 10px';
        quickDiv.style.boxSizing = 'border-box';

        const labels = ['1日', '5日', '1か月', '6か月', '年初来', '1年', '3年', '5年', '最大'];
        for (const lbl of labels) {
          const b = document.createElement('button');
          b.type = 'button';
          b.textContent = lbl;
          b.style.fontSize = '12px';
          b.style.padding = '6px 10px';
          b.style.borderRadius = '999px';
          b.style.border = '1px solid rgba(49,51,63,0.25)';
          b.style.background = 'rgba(255,255,255,0.9)';
          b.style.color = 'rgba(49,51,63,0.95)';
          b.style.whiteSpace = 'nowrap';
          b.style.cursor = 'pointer';
          b.addEventListener('click', () => applyQuickRange(lbl));
          quickDiv.appendChild(b);
        }

        const msg = document.createElement('div');
        msg.id = 'quickmsg';
        msg.style.marginLeft = 'auto';
        msg.style.alignSelf = 'center';
        msg.style.fontSize = '11px';
        msg.style.color = 'rgba(49,51,63,0.55)';
        msg.style.padding = '0 0 4px 0';
        msg.style.whiteSpace = 'nowrap';
        quickDiv.appendChild(msg);
      } catch (e) {}
    }

    function _setQuickMsg(text) {
      try {
        const el = quickDiv && quickDiv.querySelector ? quickDiv.querySelector('#quickmsg') : null;
        if (el) el.textContent = text || '';
      } catch (e) {}
    }

    function _datePart(s) {
      return String(s || '').slice(0, 10);
    }

    function _parseYmdUtc(ymd) {
      const p = String(ymd || '').split('-').map((x) => parseInt(x, 10));
      if (!p || p.length !== 3 || !p[0] || !p[1] || !p[2]) return null;
      return new Date(Date.UTC(p[0], p[1] - 1, p[2]));
    }

    function _addMonthsUtc(dt, months) {
      const y = dt.getUTCFullYear();
      const m = dt.getUTCMonth();
      const d = dt.getUTCDate();
      const base = new Date(Date.UTC(y, m + months, 1));
      const last = new Date(Date.UTC(base.getUTCFullYear(), base.getUTCMonth() + 1, 0)).getUTCDate();
      return new Date(Date.UTC(base.getUTCFullYear(), base.getUTCMonth(), Math.min(d, last)));
    }

    function _addYearsUtc(dt, years) {
      return _addMonthsUtc(dt, years * 12);
    }

    function _buildDateInfo(xs) {
      try {
        if (!xs || xs.length < 2) return null;
        const uniqueDates = [];
        const firstIndex = {};
        let prev = null;
        for (let i = 0; i < xs.length; i++) {
          const d = _datePart(xs[i]);
          if (!d) continue;
          if (d !== prev) {
            uniqueDates.push(d);
            firstIndex[d] = i;
            prev = d;
          }
        }
        if (uniqueDates.length === 0) return null;
        return { xs, uniqueDates, firstIndex };
      } catch (e) {
        return null;
      }
    }

    function _firstIndexFromThreshold(xs, thresholdUtc) {
      const info = _buildDateInfo(xs);
      if (!info) return 0;
      for (const d of info.uniqueDates) {
        const du = _parseYmdUtc(d);
        if (du && du.getTime() >= thresholdUtc.getTime()) {
          return info.firstIndex[d] || 0;
        }
      }
      return 0;
    }

    function _activateData(xsView, seriesView) {
      try {
        tableData = tableData || {};
        tableData.x = xsView;
        series = seriesView || {};
        lastIndex = -1;
        try {
          xMs = xsView.map((s) => Date.parse(s));
        } catch (e) {
          xMs = null;
        }
        buildTableSkeleton();
        if (xMs && xMs.length > 0) scheduleTableUpdate(xMs.length - 1);
      } catch (e) {}
    }

    function _applyRangebreaks(isIntraday) {
      try {
        const allTse = order && order.length > 0 && order.every((t) => String(t).endsWith('.T'));
        const allUs = order && order.length > 0 && order.every((t) => !String(t).endsWith('.T'));
        const upd = { };
        if (isIntraday && (allTse || allUs)) {
          if (allTse) {
            upd['xaxis.rangebreaks'] = [
              { bounds: ['sat', 'mon'] },
              { bounds: [15.5, 9.0], pattern: 'hour' },
              { bounds: [11.5, 12.5], pattern: 'hour' },
            ];
          } else {
            upd['xaxis.rangebreaks'] = [
              { bounds: ['sat', 'mon'] },
              { bounds: [16.0, 9.5], pattern: 'hour' },
            ];
          }
        } else if (isIntraday && !allTse && !allUs) {
          // Mixed markets (JP + US):
          // - We overlay both markets in their *local clock* time (not absolute time).
          // - Therefore, we can safely remove hours that are outside *both* sessions
          //   (night hours), which eliminates large blank gaps between days.
          // - Do NOT apply JP lunch-break rangebreak here (it would hide US midday).
          upd['xaxis.rangebreaks'] = [
            { bounds: ['sat', 'mon'] },
            { bounds: [16.0, 9.0], pattern: 'hour' },
          ];
        } else {
          upd['xaxis.rangebreaks'] = null;
        }
        Plotly.relayout(chartDiv, upd);
      } catch (e) {}
    }

    function applyQuickRange(lbl) {
      try {
        if (!chartDiv || typeof Plotly === 'undefined') return;
        function _afterPlotly(res, cb) {
          try {
            if (res && typeof res.then === 'function') res.then(cb);
            else cb();
          } catch (e) {
            try { cb(); } catch (e2) {}
          }
        }

        const wantIntraday = (lbl === '1日' || lbl === '5日');
        const useIntraday = !!(
          wantIntraday &&
          datasets &&
          datasets.intraday &&
          datasets.intraday.x &&
          datasets.intraday.x.length >= 2 &&
          datasets.intraday.series &&
          Object.keys(datasets.intraday.series).length > 0
        );
        const ds = useIntraday
          ? datasets.intraday
          : (datasets && datasets.daily && datasets.daily.x && datasets.daily.x.length >= 2
            ? datasets.daily
            : ((tableData && tableData.x && tableData.x.length >= 2) ? { x: tableData.x, series: series } : null));
        if (!ds) {
          _setQuickMsg(`${lbl}: dataなし`);
          return;
        }

        const xs = ds.x || [];
        const raw = ds.series || {};
        _setQuickMsg(`${lbl}: ${useIntraday ? '分足' : (wantIntraday ? '日足(代替)' : '日足')} ${xs.length}`);
        const info = _buildDateInfo(xs);
        if (!info) {
          _setQuickMsg(`${lbl}: date info失敗`);
          return;
        }
        const lastX = info.xs[info.xs.length - 1];
        const lastYmd = info.uniqueDates[info.uniqueDates.length - 1];
        const lastUtc = _parseYmdUtc(lastYmd);
        if (!lastUtc) return;

        function _prevCloseFromDaily(ticker, ymd) {
          try {
            const d = datasets && datasets.daily;
            if (!d || !d.x || !d.series) return null;
            const xsD = d.x;
            const arrD = d.series[ticker];
            if (!xsD || xsD.length < 2 || !arrD || arrD.length !== xsD.length) return null;
            for (let i = xsD.length - 1; i >= 0; i--) {
              const di = _datePart(xsD[i]);
              if (!di || di >= ymd) continue;
              const v = arrD[i];
              if (v != null && isFinite(v)) return v;
            }
            return null;
          } catch (e) {
            return null;
          }
        }

        function _prevCloseFromDataset(ds, ticker, ymd) {
          try {
            if (!ds || !ds.x || !ds.series) return null;
            const xs0 = ds.x;
            const arr0 = ds.series[ticker];
            if (!xs0 || xs0.length < 2 || !arr0 || arr0.length !== xs0.length) return null;
            for (let i = xs0.length - 1; i >= 0; i--) {
              const di = _datePart(xs0[i]);
              if (!di || di >= ymd) continue;
              const v = arr0[i];
              if (v != null && isFinite(v)) return v;
            }
            return null;
          } catch (e) {
            return null;
          }
        }

        function _restyleAndRelayout(xUpd, yUpd, layoutUpd, cb) {
          try {
            const n = Math.min(
              (chartDiv && chartDiv.data && chartDiv.data.length) ? chartDiv.data.length : xUpd.length,
              xUpd.length,
              yUpd.length
            );
            const traceIdx = Array.from({ length: n }, (_, i) => i);
            const x2 = xUpd.slice(0, n);
            const y2 = yUpd.slice(0, n);
            const r1 = Plotly.restyle(chartDiv, { x: x2, y: y2 }, traceIdx);
            const r2 = Plotly.relayout(chartDiv, layoutUpd || {});
            _afterPlotly(r1, () => _afterPlotly(r2, () => { try { cb && cb(); } catch (e) {} }));
          } catch (e) {
            try { _setQuickMsg(`${lbl}: update失敗`); } catch (e2) {}
          }
        }

        if (lbl === '最大') {
          const xsView = xs.slice(0);
          const outSeries = {};
          const startYmd = _datePart(xsView[0]);
          for (const t of order) {
            const arr = raw[t];
            if (!arr || arr.length !== xs.length) continue;
            let base = _prevCloseFromDaily(t, startYmd);
            if (!(base != null && isFinite(base) && base > 0)) {
              base = arr.find((v) => v != null && isFinite(v) && v > 0);
            }
            if (!base) continue;
            outSeries[t] = arr.map((v) => (v != null && isFinite(v)) ? (v / base) : null);
          }
          const xUpd = order.map(() => xsView);
          const yUpd = order.map((t) => outSeries[t] || new Array(xsView.length).fill(null));
          _restyleAndRelayout(xUpd, yUpd, { 'xaxis.autorange': true }, () => {
            _applyRangebreaks(useIntraday);
            _activateData(xsView, outSeries);
            try { suppressHoverLabels(); } catch (e) {}
            setFrameHeight();
          });
          return;
        }

        let startIdx = 0;
        if (lbl === '1日') {
          startIdx = info.firstIndex[lastYmd] || 0;
        } else if (lbl === '5日') {
          const u = info.uniqueDates;
          const startYmd = u[Math.max(0, u.length - 5)];
          startIdx = info.firstIndex[startYmd] || 0;
        } else if (lbl === '1か月') {
          startIdx = _firstIndexFromThreshold(xs, _addMonthsUtc(lastUtc, -1));
        } else if (lbl === '6か月') {
          startIdx = _firstIndexFromThreshold(xs, _addMonthsUtc(lastUtc, -6));
        } else if (lbl === '年初来') {
          const y = lastUtc.getUTCFullYear();
          startIdx = _firstIndexFromThreshold(xs, new Date(Date.UTC(y, 0, 1)));
        } else if (lbl === '1年') {
          startIdx = _firstIndexFromThreshold(xs, _addYearsUtc(lastUtc, -1));
        } else if (lbl === '3年') {
          startIdx = _firstIndexFromThreshold(xs, _addYearsUtc(lastUtc, -3));
        } else if (lbl === '5年') {
          startIdx = _firstIndexFromThreshold(xs, _addYearsUtc(lastUtc, -5));
        }

        startIdx = Math.max(0, Math.min(startIdx, xs.length - 2));
        const xsView = xs.slice(startIdx);
        const startYmd = _datePart(xsView[0]);
        const outSeries = {};
        for (const t of order) {
          const arr = raw[t];
          if (!arr || arr.length !== xs.length) continue;
          const view = arr.slice(startIdx);
          // Normalize to the *previous close before the window start date*.
          // Example: "5日" -> base = close of the day before the first day in view.
          // This keeps the overall chart style (single baseline for the whole range)
          // while aligning "今日" with previous-close-based displays like Google Finance.
          let base = _prevCloseFromDaily(t, startYmd);
          if (!(base != null && isFinite(base) && base > 0)) {
            base = _prevCloseFromDataset(ds, t, startYmd);
          }
          if (!(base != null && isFinite(base) && base > 0)) {
            base = null;
            for (let i = 0; i < view.length; i++) {
              const v = view[i];
              if (v != null && isFinite(v) && v > 0) { base = v; break; }
            }
          }
          if (!base) continue;
          outSeries[t] = view.map((v) => (v != null && isFinite(v)) ? (v / base) : null);
        }
        const xUpd = order.map(() => xsView);
        const yUpd = order.map((t) => outSeries[t] || new Array(xsView.length).fill(null));
        _restyleAndRelayout(xUpd, yUpd, { 'xaxis.range': [xsView[0], xsView[xsView.length - 1]] }, () => {
          _applyRangebreaks(useIntraday);
          _activateData(xsView, outSeries);
          try { suppressHoverLabels(); } catch (e) {}
          setFrameHeight();
        });
      } catch (e) {}
    }

    function prepareTablePayload(payload) {
      tableData = payload || null;
      order = (payload && payload.order) ? payload.order : [];
      names = (payload && payload.names) ? payload.names : {};
      colors = (payload && payload.colors) ? payload.colors : {};
      series = (payload && payload.series) ? payload.series : {};
      datasets = {
        daily: (payload && payload.daily) ? payload.daily : null,
        intraday: (payload && payload.intraday) ? payload.intraday : null,
      };
      xMs = null;
      lastIndex = -1;
      try {
        const xs = (payload && payload.x) ? payload.x : [];
        xMs = xs.map((s) => Date.parse(s));
      } catch (e) {
        xMs = null;
      }
      buildTableSkeleton();
      if (xMs && xMs.length > 0) scheduleTableUpdate(xMs.length - 1);
      buildQuickBar();
    }

    function renderFigure(fig, heightPx, payload, widthPx) {
      try {
        prepareTablePayload(payload || null);

        if (!fig || !fig.data) {
          if (typeof Plotly !== 'undefined') Plotly.purge(chartDiv);
          setFrameHeight();
          return;
        }

        fig.layout = fig.layout || {};
        fig.layout.showlegend = false;

        // Disable on-chart hover labels (mobile tap shows large hover box otherwise).
        // We still rely on hover/click/touch events to sync the table.
        try {
          if (fig.data && Array.isArray(fig.data)) {
            for (const tr of fig.data) {
              // Disable hover labels but keep hover/click events for mobile/desktop sync
              tr.hoverinfo = 'none';
              tr.hovertemplate = '';
            }
          }
        } catch (e) {}


        // Ensure enough bottom margin for x-axis labels
        fig.layout.margin = fig.layout.margin || {};
        fig.layout.margin.b = Math.max(fig.layout.margin.b || 0, 60);

        // Enable vertical spikeline on x-axis (mouse & touch).
        // Spikelines are rendered in Plotly's hoverlayer; do not hide the whole hoverlayer.
        fig.layout.hovermode = fig.layout.hovermode || 'x';

        // Keep hover/click events (for table sync) but make hover label as small/transparent as possible.
        fig.layout.hoverlabel = fig.layout.hoverlabel || {};
        fig.layout.hoverlabel.bgcolor = 'rgba(0,0,0,0)';
        fig.layout.hoverlabel.bordercolor = 'rgba(0,0,0,0)';
        fig.layout.hoverlabel.font = fig.layout.hoverlabel.font || {};
        fig.layout.hoverlabel.font.size = 1;
        fig.layout.hoverlabel.font.color = 'rgba(0,0,0,0)';
        fig.layout.hoverlabel.namelength = 0;

        fig.layout.xaxis = fig.layout.xaxis || {};
        fig.layout.xaxis.showspikes = true;
        fig.layout.xaxis.spikemode = 'across';
        fig.layout.xaxis.spikesnap = 'cursor';
        fig.layout.xaxis.spikedash = 'dot';
        fig.layout.xaxis.spikethickness = 1;
        // Keep spike visible even when unified hover labels are hidden.
        fig.layout.xaxis.spikecolor = fig.layout.xaxis.spikecolor || 'rgba(0,0,0,0.35)';

        if (widthPx && wrapDiv) {
          try {
            const w = Math.max(parseInt(widthPx, 10) || 0, 320);
            wrapDiv.style.maxWidth = w + 'px';
            wrapDiv.style.marginLeft = 'auto';
            wrapDiv.style.marginRight = 'auto';
          } catch (e) {}
        } else if (wrapDiv) {
          try { wrapDiv.style.maxWidth = ''; } catch (e) {}
        }

        if (heightPx) {
          try {
            const h = Math.max(parseInt(heightPx, 10) || 0, 200);
            chartDiv.style.height = h + 'px';
            // Ensure Plotly respects the new height even when responsive is enabled.
            fig.layout.height = h;
          } catch (e) {}
        }

                if (typeof Plotly === 'undefined') {
          tableDiv.innerHTML = '<div style="padding:8px 10px;color:#b00;font-family:sans-serif;font-size:12px">Plotly failed to load in the component iframe.</div>';
          setFrameHeight();
          return;
        }

const config = { displayModeBar: false, responsive: true };

        Plotly.react(chartDiv, fig.data, fig.layout, config).then(() => {
          suppressHoverLabels();
          attachHoverHandler();
          setFrameHeight();
        });
      } catch (e) {
        setFrameHeight();
      }
    }

    function suppressHoverLabels() {
      try {
        const hoverLayer = chartDiv.querySelector('.hoverlayer');
        if (!hoverLayer) return;
        const labels = hoverLayer.querySelectorAll('.hovertext, .hovertext *, .hoverlabel, .hoverbg');
        labels.forEach((el) => {
          el.style.display = 'none';
          el.style.opacity = '0';
        });
      } catch (e) {}
    }

    let _hoverAttached = false;
    function attachHoverHandler() {
      if (_hoverAttached) return;
      if (!chartDiv || typeof chartDiv.on !== 'function') return;
      _hoverAttached = true;
      try {
        chartDiv.on('plotly_hover', (ev) => {
          const pt = ev && ev.points && ev.points[0];
          const x = pt ? pt.x : null;
          let ms;
          if (x instanceof Date) ms = x.getTime();
          else if (typeof x === 'number') ms = x;
          else ms = Date.parse(x);
          const idx = nearestIndex(ms);
          if (idx >= 0) scheduleTableUpdate(idx);
          suppressHoverLabels();
        });
        // MOBILE_TOUCH_V1
        // Mobile/touch: tap updates table (hover often doesn't fire on touch)
        chartDiv.on('plotly_click', (ev) => {
          try {
            const pt = ev && ev.points && ev.points[0];
            const x = pt ? pt.x : null;
            let ms;
            if (x instanceof Date) ms = x.getTime();
            else if (typeof x === 'number') ms = x;
            else ms = Date.parse(x);
            const idx = nearestIndex(ms);
            if (idx >= 0) scheduleTableUpdate(idx);
            suppressHoverLabels();
          } catch (e) {}
        });

        // Finger drag: convert pixel -> x (ms) using Plotly axis mapping
        let _lastTouchT = 0;
        chartDiv.addEventListener('touchmove', (e) => {
          const now = performance.now();
          if (now - _lastTouchT < 40) return; // ~25fps throttle
          _lastTouchT = now;
          try {
            const t = e.touches && e.touches[0];
            if (!t) return;
            if (!chartDiv._fullLayout || !chartDiv._fullLayout.xaxis) return;
            const xa = chartDiv._fullLayout.xaxis;
            const rect = chartDiv.getBoundingClientRect();
            const xpx = t.clientX - rect.left;
            const xv = xa.p2d(xpx);
            if (xv === undefined || xv === null || Number.isNaN(xv)) return;
            const ms = (xv instanceof Date) ? xv.getTime() : Number(xv);
            if (!Number.isFinite(ms)) return;
            const idx = nearestIndex(ms);
            if (idx >= 0) scheduleTableUpdate(idx);
          } catch (err) {}
        }, { passive: true });

        chartDiv.on('plotly_unhover', () => {
          // Keep last hovered value (no change)
        });
        chartDiv.on('plotly_relayout', () => { setFrameHeight(); });
      } catch (e) {
        _hoverAttached = false;
      }
    }

    // ResizeObserver: Plotly does not always detect parent layout changes (e.g., Streamlit sidebar).
    // We observe the component root and force Plotly resize without triggering a Streamlit rerun.
    let _ro = null;
    let _resizeRaf = false;
    function _schedulePlotlyResize() {
      if (_resizeRaf) return;
      _resizeRaf = true;
      window.requestAnimationFrame(() => {
        _resizeRaf = false;
        try {
          if (typeof Plotly !== 'undefined' && chartDiv && chartDiv.data) {
            Plotly.Plots.resize(chartDiv);
          }
        } catch (e) {}
        try { setFrameHeight(); } catch (e) {}
      });
    }

    try {
      if (typeof ResizeObserver !== 'undefined') {
        _ro = new ResizeObserver(() => _schedulePlotlyResize());
        _ro.observe(document.body);
      } else {
        window.addEventListener('resize', _schedulePlotlyResize);
      }
    } catch (e) {}

	    window.addEventListener('message', (event) => {
      const data = event.data;
      if (!data || data.type !== 'streamlit:render') return;
      const args = data.args || {};
      const key = args._fig_key || null;
      if (key && key === lastFigKey) {
        setFrameHeight();
        return;
      }
      lastFigKey = key;
      renderFigure(args.fig || null, args.height || null, args.table || null);
    });

    postToStreamlit({ type: 'streamlit:componentReady', apiVersion: 1 });
    setFrameHeight();
  </script>
</body>
</html>
